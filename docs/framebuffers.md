Framebuffers and Buffer Swapping {#framebufferSwapping}
================================

Somes pieces of terminology that come up a lot in the documentation for CX are framebuffer, front buffer, back buffer, and swap buffers. What exactly are these things?

A framebuffer is fairly easy to explain in the rough by example. The contents of the screen of a computer are stored in a framebuffer. A framebuffer is essentially a rectangle of pixels where each pixel can be set to display any color. Framebuffers do not always have the same number of pixels as the screen: you can have framebuffers that are smaller or larger than the size of the screen. Framebuffers larger than the screen don't really do much for you as you cannot fit the whole thing on the screen. In CX, framebuffers are typically worked with through the abstraction of an ofFbo.

There are two special framebuffers: The front buffer and the back buffer. These are created by OpenGL automatically as part of starting OpenGL. The size of these special framebuffers is functionally the same as the size of the window (or the whole screen, if in full screen mode). The front buffer contains what is shown on the screen. The back buffer is not presented on the screen, so it can be rendered to at any time without affecting what is visible on the screen. Typically, when you render stuff in CX, you call CX::CX_Display::beginDrawingToBackBuffer() and CX::CX_Display::endDrawingToBackBuffer() around whatever you are rendering. This causes drawing that happens between the two function calls to be rendered to the back buffer. 

What you have rendered to the back buffer has no effect on what you see on screen until you swap the contents of the front and back buffers. This isn't always a true swap, in that that the back buffer does not end up with the contents of the front buffer in it. On many systems, the back buffer is copied to the front buffer and is itself unchanged. This swap can be done by using different functions of the CX_Display: BLOCKING_swapFrontAndBackBuffers(), swapFrontAndBackBuffers(), or BLOCKING_setAutoSwapping(). These functions are not interchangable, so make sure you are using the right one for your application.


Vertical Synchronization
------------------------

Vertical synchronization (Vsync) is the process by which the swaps of the front and back are synchronized to the refreshes of the monitor in order to prevent vertical tearing. Vertical tearing happens when one part of a scene is being drawn onto the monitor and a different scene is copied into the front buffer, causing parts of both scenes to be drawn at once. The "tearing" happens on the monitor where one scene abruptly becomes the other. In order to to Vsync, there must be some control over when the front buffer is drawn to. The ideal process might be that when the user requests a buffer swap the video card waits until the next vertical blank to swap the buffers. Unfortunately, what actually happens is implementation dependent, which makes writing software that will always work properly difficult. 

One problem that I have observed is that even with Vsync enabled if there have been no buffer swaps for some time (several screen refresh periods), buffer swaps can happen more quickly than expected. For example, if the buffers have not been swapped for 2.5 refresh periods and a buffer swap is requested, the buffer swap function can return immediately, not waiting until 3 refresh periods have passed to queue to swap. One process that could explain this is if when the user requests a buffer swap, if at least one vertical blank has passed since the last buffer swap, the buffers are swapped immediately. This can cause problems if the surrounding code is expecting the buffer swap to wait until the next refresh has occured to return. One possible solution to this is, after a buffer swap has been requested, to tell OpenGL to wait until all ongoing processes have completed before continuing. This can be done with glFinish() and results in a kind of "software" Vsync, as opposed to the "hardware" Vsync that is done by OpenGL internally. Calling the buffer swap function and then glFinish() works sometimes, but it isn't perfect. On some systems, this will result in a wait of two frame periods before continuing (don't ask me why). On other systems, it works just fine. You can turn on hardware or software Vsync with CX::CX_Display::setVSync().

So how do you know if you are having problems with video presentation that are related to Vsync? Probably the easiest way is to use a feature of CX::CX_SlidePresenter to learn about the timing of your stimuli. CX::CX_SlidePresenter::printLastPresentationInformation() provides a lot of timing information related to slide presentation so that you can check for errors easily. The errors can take the form of incorrect slide durations or frame counts (depending on presentation mode). If slides are consistently not started at the intended start time but the copy to the back buffer is happening in time, the most likely culprit is that something strange is going on with Vsync. If you are experiencing problems in windowed mode but not in full screen mode, you shouldn't worry. Vsync does not work properly in windowed mode in most modern operating systems due to the way in which they do window compositing.

CX provides some functionality to help deal with the Vsync annoyances. CX::CX_Display::setVSync() can turn "hardware" and "software" Vsync on or off independently so that if you experience problems you can try different solutions. You can also try different buffer swapping modes of CX_SlidePresenter (see CX::CX_SlidePresenter::Configuration::SwappingMode). One of the swapping modes (MULTI_CORE) swaps the buffers every frame in a secondary thread which avoids issues that arise from occasional buffer swapping. However, this mode should really only be used with a 2+ core CPU, so if you are working with dark ages machinery, this may not be for you.

Another option to help deal with Vsync issues is to force Vsync on or off in your video card driver. Modern AMD and Nvidia drivers allow you to force Vsync on or off for specific applications or globally, which seems to be more reliable than turning Vsync on or off in software. If you force Vsync to a setting in the video card driver, the "hardware" Vsync setting of CX::CX_Display::setVSync() will probably not do anything, but the software setting probably would (although it is not clear that you would want to have both hardware and software Vsync working at the same time).



